---
title: Свойства объекта, for-in, обёртки для примитивов
slideOptions:
  transition: slide
---

# Свойства объекта, for-in, обёртки для примитивов

###### tags: `netology` `advanced js`

---

## План занятия
1. Объекты
1. Свойства объекта
1. Прототипы и цепочки прототипов
1. Object
1. Перебор свойств
1. get/set
1. Обёртки для примитивов

---

## Объекты

В JS объекты представляют из себя набор свойств (пар ключ-значение).

Вопрос к аудитории:
> Зачем нам нужны объекты?

---

## Свойства объекта

Вспомним, варианты доступа к свойствам объекта:

```javascript=
const user = {
  name: 'Nemo',
  balance: 10000,
};
// Вариант 1: 'dot notation'
console.log(user.name);
// Вариант 2: 'bracket notation'
console.log(user['name']);
```

Вопрос к аудитории:
> Когда и какой способ предпочтительнее?

---

## Извлечение свойств

ES6 предоставляет нам удобный способ извлечения свойств с помощью **Object Destructing**:
```javascript=
const {name, balance} = user;
```

---

## Добавление и удаление свойств

В JS мы в любой момент можем как добавить объекту новое свойство, так и удалить его:
```javascript=
user.address = '...';
user['address'] = '...';

delete user.address;
```

---

## Доступ к несуществующим свойствам

Если мы удалили свойство у объекта (или его просто никогда в объекте не было), то попытка доступа закончится тем, что мы получим `undefined`:
```javascript=
console.log(user.address);
// undefined
```

---

## Проверка на `undefined`

Вопрос к аудитории:
> Чем плох следующий код?

```javascript=
if (user.address === undefined) {
  // No such property
}
```

---

## Проверка на `undefined`

На самом деле, свойство в объекте может и быть, а его значение может быть равным `undefined`. Тогда проверка и последующая логика будут некорректной.

---

## Object Destructing: Default Values

При **Object Destructing** мы можем назначать переменным default-значения, если таких полей в объекте нет:
```javascript=
const {name, balance, address = 'Не указан'} = user;
```

---

## Nested Object Destructing

А что если объект включает в себя свойство, представляющее из себя объект. И нам нужно извлечь свойства из этого объекта? Поможет ли **Object Destructing**?

```javascript=
user.manager = {
  name: 'Светлана',
  ...
};

const {manager: {name}} = user;
```

Но при этом, имя менеджера сохранится в переменную `name` (а такая уже создана).

---

## Переименование при Object Destructing

```javascript=
const {manager: {name: managerName}} = user;
```

Теперь имя менеджера сохранится в переменную `managerName`;

Удалим свойство `manager`, чтобы оно нам в дальнейшем не мешало:
```javascript=
delete user.manager;
```

---

## Rest

В ES2018 появилась возможность использовать конструкцию `...rest` при `Ojbect destruction`:

```javascript=
const {name, ..rest} = user;
```
В `rest` будет:
```json=
{
  "balance": 10000
}
```

---

## Rest

Это даёт замечательные возможности по созданию `Shallow Copy` для объектов:

```javascript=
const copy = {...user};
```

А также для объединения нескольких объектов в один:
```javascript=
const merged = {...first, ...second};
```

---

## Задача

Представим, что мы реализуем CRM-систему, где объекту можно добавлять произвольные поля, например:
1. Ответственный
1. Приоритет
1. Категория
1. и т.д.

Т.е. у одних объектов такие свойства могут быть, а других - нет. Как найти все объекты, у которых есть определённое свойство?

---

## in

Оператор `in` позволяет проверить наличие свойства в объекте*:
```javascript=
console.log('name' in user); // true
console.log('address' in user); // false
console.log('toString' in user); // true!
```

С первыми двумя примерами всё понятно, но почему в последнем `true`?

---

## Прототипы

:::info
JS - объектно-ориентированный язык, основанный на прототипах
:::

Т.е. у каждого объекта есть специальное свойство `__proto__`, в котором может находиться другой объект. И когда мы пытаемся обратиться к определённому свойству нашего объекта, то JS сначала ищет это свойство в нашем объекте, потом в прототите, потом в прототипе прототипа и т.д.

---

## Прототипы

```javascript=
console.log(user.__proto__);
```

![](https://i.imgur.com/ZC4T0CZ.png)


---

## Литеральная форма и прототипы

Если вы создаёте объект с помощью литерала, то его прототипом автоматически назначается объект типа [`Object`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object#Object_instances), в котором и определено свойство `toString`.

Если быть точнее, то `Object.prototye`.


---

## Прототипы

```javascript=
console.log(user.__proto__.__proto__);
```

![](https://i.imgur.com/v9S0F0h.png)

---

## Object

JS содержит встроенный объект [`Object`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), который содержит ряд полезных методов для работы с объектами.

В частности, он содержит статический метод `setPrototypeOf`, который позволяет заменить прототип объекта.

```javascript=
const entry = {
  id: 999,
}

Object.setPrototypeOf(user, entry);

console.log(user.id);
```

:::danger
Не используйте метод `setPrototypeOf` в production-коде. Мы его используем только для демонстрации концепций языка
:::

---

## Цепочка прототипов

![](https://i.imgur.com/gurQdLz.png)

---

## Задача

Хорошо, мы разобрались с тем, как проверить, есть свойство или нет (правда осталась проблема с прототипами), но что, если нам нужно вывести все свойства?

Например, мы хотим отобразить все свойства объекта в карточке (в виде таблички).

---

## Перебор свойств

Итак, мы посмотрели на оператор `in`, который позволяет проверять наличие свойства в объекте (включая цепочку прототипа), давайте посмотрим на `for...in`:

```javascript=
for (const prop in user) {
  console.log(prop);
}
```

![](https://i.imgur.com/wqImYbP.png)

---

## hasOwnProperties

Прототип `Object.prototype` дарит каждому объекту метод `hasOwnProperty`, который позволяет определить, принадлежит ли свойство нашему объекту или берётся из цепочки прототипов:

```javascript=
for (const prop in user) {
  if (user.hasOwnProperty(prop)) {
    console.log(prop);
  }
}
```

![](https://i.imgur.com/tZnBmjK.png)

---

## Нельзя ли попроще?

Можно, есть статический метод `Object.keys`, который массив собственных перечисляемых свойств (не включая цепочку прототипов).

---

## Object.defineProperty & Object.defineProperties

При создании свойства в объекте, мы можем определить ряд характеристик (дескриптор), которые определяют поведение этого свойства. Вот, что по этому поводу говорит [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty):
* configurable - свойство может быть удалено из содержащего его объекта
* enumerable - свойство можно увидеть через перечисление свойств
* value - значение, ассоциированное со свойством
* writable - значение, ассоциированное со свойством, может быть изменено с помощью оператора `=`
* get - функция, используемая как `getter` свойства
* set - функция, используемая как `setter` свойства

---

## Object.getOwnPropertyDescriptor

Посмотрим на дескриптор собственных свойств объекта `user`:
```javascript=
console.log(Object.getOwnPropertyDescriptor(user, 'name'));
```

![](https://i.imgur.com/LLrsDVP.png)

---

## Object.getOwnPropertyDescriptor

Вот и ответ на вопрос, почему в `for..in` мы не видели некоторых свойств:

![](https://i.imgur.com/vd7MTov.png)

---

## Как перебрать все свойства объекта?

Если вам нужны все перечисляемые, включая цепочку прототипов, то через `for..in`

Если вам нужны все перечисляемые собственные, то `for..in` + `hasOwnProperty` (либо `Object.keys`)

---

## toString

Что происходит, когда мы пытаемся использовать объект в "строковом контексте"?

```javascript=
console.log(`Current user: ${user}`);
// Current user: [object Object]
```

На самом деле вызывается метод `toString`, который определён в цепочке прототипов.

Что будет, если мы напишем свой метод `toString`? Тогда по правилам JS сначала будет искать это свойство в нашем объекте и только если не найдёт - пойдёт искать по цепочке.

---

## toString

```javascript=
user.toString = function() {
  return `User{${this.name}}`;
};
```

![](https://i.imgur.com/OtYjlVH.png)


---

## Стрелочные функции

Вопрос к аудитории:
> Почему это не сработает?
```javascript=
user.toString = () => {
  return `User {${this.name}}`;
};
```

---

## Как правильно объявлять методы?

Попробуем создать новый объект, в котором сразу в литеральной форме прописать метод.

Вариант 1:
```javascript=
const good = {
  code: '45007',
  name: 'Стильный чехол',
  description: '...',
  price: 1500,
  toString: function() {
    return `[${this.code}] ${this.name} за ${this.price} руб.`
  },
};
```

---

## Как правильно объявлять методы?

ES2015 (либо транспайлеры) позволяют нам использовать сокращённый синтаксис.
Вариант 2:
```javascript=
const good = {
  code: '45007',
  name: 'Стильный чехол',
  description: '...',
  price: 1500,
  toString() { // ES2015
    return `[${this.code}] ${this.name} за ${this.price} руб.`
  },
};
```

Старайтесь использовать более новый синтаксис (при наличии возможности).

---

## Задача

Возникает необходимость сравнения двух объектов (например, при поиске или сортировке). Варианты решения:
1. Сравнение свойств
1. `valueOf`

Со сравнением свойств всё понятно, рассмотрим `valueOf`.

---

## valueOf

Метод прототипа, вызывающийся при преобразовании объекта к примитивному типу (не к строковому контексту).

Например:
```javascript=
const project1 = { ... };
const project2 = { ... };

if (project1 > project2) {
  // TODO:
}
```

Переопределение `valueOf` позволяет нам задать "собственные правила сравнения".

---

## Как сравнивать объекты на равенство?

Только через сравнение полей.

Если хотите сравнивать в контексте приведения к примитивным типам (либо приводить к ним), то переопределяйте `valueOf`.

---

## Другие полезные методы Object

* Object.create(proto) - позволяет создать объект, используя объект (proto) в качестве прототипа
* Object.getPrototypeOf(obj) - получение прототипа объекта

---

## Задача

Нужно разработать приложение, которое позволяет задавать гео-метки, причём делать это не только на карте, а указывая пару координат в виде строки в формате: '55.7887400, 49.1221400', где первое - это широта, второе - долгота.

Как это реализовать?

---

## Свойство

```javascript=
const mark = {
  coords: ...
};

mark.coords = '55.7887400, 49.1221400';
```

Но как тогда получать в удобном виде отдельно широту, отдельно долготу?
И как построить логику обработки ошибок?

---

## Методы

```javascript=
const mark = {
  latitude: ...,
  longitude: ...,
  setCoords(value) {
    ...
  },
  getCoords() {
    ...
  },
};

mark.setCoords('55.7887400, 49.1221400');
```

---

## get/set

ES6 появилась возможность сделать подобные методы (их называют *access property*) в более удобном виде (скрыв факт того, что будет вызываться метод). 

```javascript=
const mark = {
  latitude: ...,
  longitude: ...,
  set coords(value) {
    ...
  },
  get coords() {
    ...
  },
};

mark.coords = '55.7887400, 49.1221400'; // вызов setter'а
console.log(mark.coords); // вызов getter'а
```

---

## Обёртки для примитивов

В JS все типы данных делятся на два больших класса:
* примитивы
* объекты

Например, строка - это примитив. Но при этом возможно следующее:
```javascript=
console.log('Hello world'.length);
```

Оператор `.` - обращение к свойству объекта, но строка - это примитив, а не объект.

---

## Как это происходит?

JS при использовании примитива с операторами, работающими с объектами производит следующую операцию: неявно заворачивает примитив в соответствующий объектный тип. Например, для строк - это [`String`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String).

Для чисел и boolean это будет Number и Boolean, соответственно.

---

## Зачем нужны обёртки?

Обёртки содержат полезные свойства для конкретного типа данных:
* для строк - методы поиска, замены, конвертация регистра
* для чисел - методы преобразования (различные системы счисления), константы, хранящие max и min-допустимые значения.

---

## Чем отличаются обёртки от примитивов?

Оператор `typeof` вернёт разные значения для примитива и объекта.

Оператор `===` при сравнении объекта (даже если внутри то же значение) с примитивом вернёт `false`.

---

## Итоги

Сегодня мы с вами рассмотрели достаточно много важных вещей:
1. Объекты
1. Свойства объекта
1. Прототипы и цепочки прототипов
1. Object
1. Перебор свойств
1. get/set
1. Обёртки для примитивов

---

## Спасибо за внимание! Время задавать вопросы 🙂

---